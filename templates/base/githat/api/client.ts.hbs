{{#if includeGithatFolder}}
import { githatConfig } from '../config{{#unless typescript}}.js{{/unless}}';

class GitHatApiClient {
  private baseUrl: string;

  constructor() {
    this.baseUrl = githatConfig.apiUrl;
  }

  private getToken(){{#if typescript}}: string | null{{/if}} {
    if (typeof window === 'undefined') return null;
    return localStorage.getItem('githat_accessToken');
  }

  async request{{#if typescript}}<T>{{/if}}(path{{#if typescript}}: string{{/if}}, options{{#if typescript}}?: RequestInit{{/if}}){{#if typescript}}: Promise<T>{{/if}} {
    const token = this.getToken();
    const headers{{#if typescript}}: Record<string, string>{{/if}} = {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
      ...(options?.headers as Record<string, string> || {}),
    };

    const res = await fetch(`${this.baseUrl}${path}`, {
      ...options,
      headers,
    });

    if (res.status === 401) {
      // Token expired â€” try refresh
      const refreshed = await this.refreshToken();
      if (refreshed) {
        return this.request(path, options);
      }
      throw new Error('Session expired. Please sign in again.');
    }

    if (!res.ok) {
      const body = await res.json().catch(() => ({}));
      throw new Error((body{{#if typescript}} as any{{/if}}).error || `Request failed: ${res.status}`);
    }

    return res.json();
  }

  private async refreshToken(){{#if typescript}}: Promise<boolean>{{/if}} {
    const refreshToken = typeof window !== 'undefined'
      ? localStorage.getItem('githat_refreshToken')
      : null;
    if (!refreshToken) return false;

    try {
      const res = await fetch(`${this.baseUrl}/auth/refresh`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken }),
      });
      if (!res.ok) return false;
      const data = await res.json();
      localStorage.setItem('githat_accessToken', data.accessToken);
      localStorage.setItem('githat_refreshToken', data.refreshToken);
      return true;
    } catch {
      return false;
    }
  }

  async get{{#if typescript}}<T>{{/if}}(path{{#if typescript}}: string{{/if}}) {
    return this.request{{#if typescript}}<T>{{/if}}(path, { method: 'GET' });
  }

  async post{{#if typescript}}<T>{{/if}}(path{{#if typescript}}: string{{/if}}, body{{#if typescript}}?: unknown{{/if}}) {
    return this.request{{#if typescript}}<T>{{/if}}(path, {
      method: 'POST',
      body: body ? JSON.stringify(body) : undefined,
    });
  }

  async patch{{#if typescript}}<T>{{/if}}(path{{#if typescript}}: string{{/if}}, body{{#if typescript}}?: unknown{{/if}}) {
    return this.request{{#if typescript}}<T>{{/if}}(path, {
      method: 'PATCH',
      body: body ? JSON.stringify(body) : undefined,
    });
  }

  async del{{#if typescript}}<T>{{/if}}(path{{#if typescript}}: string{{/if}}) {
    return this.request{{#if typescript}}<T>{{/if}}(path, { method: 'DELETE' });
  }
}

export const githatApi = new GitHatApiClient();
{{/if}}
